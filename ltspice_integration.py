#!/usr/bin/env python3
"""
LTSpice Integration Module for TMR Sensor Array
----------------------------------------------
This module provides functionality to export circuit schematics to LTSpice format.
It creates a bridge between the SchemDraw representation and LTSpice simulation models.
"""

import os
import re
from typing import Dict, List, Optional, Tuple, Union

# Type aliases
Component = Dict[str, Union[str, float, int]]
Node = Dict[str, Union[str, float, int]]
Circuit = Dict[str, Union[List[Component], List[Node]]]

def create_ltspice_netlist(circuit_name: str, components: List[Component], 
                          nodes: List[Node]) -> str:
    """
    Create an LTSpice netlist from components and nodes.
    
    Args:
        circuit_name: Name of the circuit
        components: List of component dictionaries
        nodes: List of node dictionaries
    
    Returns:
        LTSpice netlist as a string
    """
    netlist = [f"* {circuit_name} - LTSpice netlist"]
    netlist.append("* Generated by TMR Schematic Drawer")
    netlist.append("")
    
    # Add components to netlist
    for comp in components:
        comp_type = comp['type']
        name = comp['name']
        nodes_str = ' '.join([str(n) for n in comp['nodes']])
        value = comp.get('value', '')
        
        if comp_type == 'resistor':
            netlist.append(f"R{name} {nodes_str} {value}")
        elif comp_type == 'capacitor':
            netlist.append(f"C{name} {nodes_str} {value}")
        elif comp_type == 'opamp':
            # LTSpice operational amplifier model
            netlist.append(f"XU{name} {nodes_str} opamp")
        elif comp_type == 'voltage_source':
            netlist.append(f"V{name} {nodes_str} {value}")
        # Add other component types as needed
    
    # Add model references
    netlist.append("")
    netlist.append("* Models")
    netlist.append(".lib opamp.sub")
    netlist.append("")
    netlist.append(".end")
    
    return '\n'.join(netlist)

def create_ltspice_subcircuit(subckt_name: str, components: List[Component], 
                             nodes: List[Node], external_nodes: List[str]) -> str:
    """
    Create an LTSpice subcircuit from components and nodes.
    
    Args:
        subckt_name: Name of the subcircuit
        components: List of component dictionaries
        nodes: List of node dictionaries
        external_nodes: List of node names that are externally accessible
    
    Returns:
        LTSpice subcircuit definition as a string
    """
    subckt = [f"* {subckt_name} - LTSpice subcircuit"]
    subckt.append("* Generated by TMR Schematic Drawer")
    subckt.append("")
    
    # Subcircuit header
    ext_nodes_str = ' '.join(external_nodes)
    subckt.append(f".SUBCKT {subckt_name} {ext_nodes_str}")
    
    # Add components
    for comp in components:
        comp_type = comp['type']
        name = comp['name']
        nodes_str = ' '.join([str(n) for n in comp['nodes']])
        value = comp.get('value', '')
        
        if comp_type == 'resistor':
            subckt.append(f"R{name} {nodes_str} {value}")
        elif comp_type == 'capacitor':
            subckt.append(f"C{name} {nodes_str} {value}")
        elif comp_type == 'opamp':
            subckt.append(f"XU{name} {nodes_str} opamp")
        # Add other component types as needed
    
    # Subcircuit footer
    subckt.append(".ENDS")
    
    return '\n'.join(subckt)

def create_simulation_directives(sim_type: str, params: Dict[str, str]) -> str:
    """
    Create LTSpice simulation directives.
    
    Args:
        sim_type: Type of simulation ('tran', 'ac', 'dc', 'noise', etc.)
        params: Dictionary of simulation parameters
    
    Returns:
        LTSpice simulation directives as a string
    """
    directives = ["* Simulation Directives"]
    
    if sim_type == 'tran':
        step = params.get('step', '1u')
        stop = params.get('stop', '1m')
        directives.append(f".tran {step} {stop}")
    elif sim_type == 'ac':
        points = params.get('points', '101')
        fstart = params.get('fstart', '1')
        fstop = params.get('fstop', '1Meg')
        directives.append(f".ac dec {points} {fstart} {fstop}")
    elif sim_type == 'dc':
        source = params.get('source', 'V1')
        start = params.get('start', '0')
        stop = params.get('stop', '5')
        step = params.get('step', '0.1')
        directives.append(f".dc {source} {start} {stop} {step}")
    elif sim_type == 'monte':
        runs = params.get('runs', '100')
        directives.append(f".step param run 1 {runs} 1")
        directives.append(".save all")
        
    # Add common directives
    if params.get('temp_sweep', False):
        temp_start = params.get('temp_start', '-40')
        temp_stop = params.get('temp_stop', '85')
        temp_step = params.get('temp_step', '5')
        directives.append(f".step temp {temp_start} {temp_stop} {temp_step}")
    
    return '\n'.join(directives)

def parse_schemdraw_circuit(drawing: object) -> Tuple[List[Component], List[Node]]:
    """
    Parse a SchemDraw drawing object to extract components and nodes.
    
    Args:
        drawing: SchemDraw Drawing object
    
    Returns:
        Tuple containing (components list, nodes list)
    """
    components = []
    nodes = []
    
    # This is a placeholder function that would need to be implemented
    # based on the actual structure of SchemDraw objects
    # The implementation depends on how SchemDraw stores component information
    
    # Example (not functional, just illustrative):
    # for element in drawing.elements:
    #     comp = {
    #         'type': element.element_type,
    #         'name': element.label,
    #         'nodes': element.connections,
    #         'value': element.value
    #     }
    #     components.append(comp)
    
    return components, nodes

def export_to_ltspice(circuit_name: str, drawing: object, 
                     output_dir: str = 'ltspice_models') -> str:
    """
    Export a SchemDraw drawing to LTSpice format.
    
    Args:
        circuit_name: Name of the circuit
        drawing: SchemDraw Drawing object
        output_dir: Directory to save LTSpice files
    
    Returns:
        Path to the generated LTSpice file
    """
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Parse the drawing to extract components and nodes
    components, nodes = parse_schemdraw_circuit(drawing)
    
    # Create the netlist
    netlist = create_ltspice_netlist(circuit_name, components, nodes)
    
    # Create simulation directives for a transient analysis
    sim_params = {
        'step': '0.1u',
        'stop': '10m',
        'temp_sweep': True,
        'temp_start': '0',
        'temp_stop': '70',
        'temp_step': '10'
    }
    sim_directives = create_simulation_directives('tran', sim_params)
    
    # Combine netlist and simulation directives
    ltspice_content = netlist + '\n\n' + sim_directives
    
    # Write to file
    output_file = os.path.join(output_dir, f"{circuit_name}.net")
    with open(output_file, 'w') as f:
        f.write(ltspice_content)
    
    return output_file

def create_ltspice_model_library(model_specs: Dict[str, Dict], 
                                output_dir: str = 'ltspice_models') -> str:
    """
    Create an LTSpice model library file containing component models.
    
    Args:
        model_specs: Dictionary of model specifications
        output_dir: Directory to save model library
    
    Returns:
        Path to the generated model library file
    """
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    model_library = ["* TMR Sensor Array - Component Models"]
    model_library.append("* Generated by TMR Schematic Drawer")
    model_library.append("")
    
    # Add each model to the library
    for model_name, specs in model_specs.items():
        model_type = specs.get('type', 'subckt')
        
        if model_type == 'subckt':
            model_library.append(f".SUBCKT {model_name} {specs.get('ports', '')}")
            for line in specs.get('definition', []):
                model_library.append(line)
            model_library.append(".ENDS")
        else:
            model_library.append(f".MODEL {model_name} {specs.get('class', '')} (")
            params = []
            for key, value in specs.get('parameters', {}).items():
                params.append(f"{key}={value}")
            model_library.append("+ " + " ".join(params))
            model_library.append(")")
        
        model_library.append("")
    
    # Write to file
    output_file = os.path.join(output_dir, "tmr_models.lib")
    with open(output_file, 'w') as f:
        f.write('\n'.join(model_library))
    
    return output_file

def generate_ltspice_schematic_file(circuit_name: str, netlist_file: str,
                                  components_layout: List[Dict],
                                  output_dir: str = 'ltspice_models') -> str:
    """
    Generate an LTSpice schematic file (.asc) based on a netlist and component layout.
    
    Args:
        circuit_name: Name of the circuit
        netlist_file: Path to the netlist file
        components_layout: List of component layout information
        output_dir: Directory to save schematic file
    
    Returns:
        Path to the generated schematic file
    """
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # This is a simplified implementation.
    # In a real implementation, you would need to generate proper ASC file format
    # which requires understanding LTSpice's ASC file structure
    
    asc_content = ["Version 4"]
    asc_content.append(f"SHEET 1 880 680")
    asc_content.append(f"WIRE 0 0 0 0")  # Placeholder
    
    # Add components (simplified representation)
    for comp in components_layout:
        x, y = comp.get('position', (0, 0))
        comp_type = comp.get('type', '')
        name = comp.get('name', '')
        value = comp.get('value', '')
        
        # This is just a placeholder. Real ASC files have specific format requirements
        asc_content.append(f"SYMBOL {comp_type} {x} {y} R0")
        asc_content.append(f"SYMATTR InstName {name}")
        asc_content.append(f"SYMATTR Value {value}")
    
    # Add netlist as text
    with open(netlist_file, 'r') as f:
        netlist_content = f.read()
    
    asc_content.append(".backanno")
    asc_content.append(".end")
    
    # Write to file
    output_file = os.path.join(output_dir, f"{circuit_name}.asc")
    with open(output_file, 'w') as f:
        f.write('\n'.join(asc_content))
    
    return output_file

# Example usage in a main function
def main():
    """Example usage of the LTSpice integration functions."""
    # Define example component models
    model_specs = {
        'AD8220': {
            'type': 'subckt',
            'ports': 'IN+ IN- REF RG VS+ VS- OUT',
            'definition': [
                "* AD8220 Instrumentation Amplifier",
                "X1 IN+ REF VS+ VS- BUFF OUT OPAMP1",
                "X2 IN- REF VS+ VS- BUFF OPAMP1",
                "RG1 RG BUFF 1",
                ".MODEL OPAMP1 AMP(A=100K GAIN=110dB)"
            ]
        },
        'OPA2387': {
            'type': 'subckt',
            'ports': 'IN+ IN- VS+ VS- OUT',
            'definition': [
                "* OPA2387 Precision Op-Amp",
                "A1 IN+ IN- VS+ VS- OUT OPAMP2",
                ".MODEL OPAMP2 AMP(A=1E6 GAIN=120dB GBW=10MEG)"
            ]
        }
    }
    
    # Create model library
    create_ltspice_model_library(model_specs)
    
    print("Created LTSpice model library: ltspice_models/tmr_models.lib")
    print("LTSpice integration module ready for use.")

if __name__ == "__main__":
    main() 